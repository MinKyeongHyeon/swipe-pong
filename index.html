<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>Panel Puzzle</title>

    <style>
      body {
        margin: 0;
        background: #111;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
      }

      #game {
        position: relative;
      }

      #board {
        display: grid;
        grid-template-columns: repeat(6, 40px);
        grid-template-rows: repeat(12, 40px);
        gap: 2px;
        background: #333;
        padding: 6px;
        position: relative;
      }

      .container {
        display: flex;
        gap: 18px;
        align-items: flex-start;
      }

      #scoreboard {
        width: 140px;
        color: #fff;
        font-family: sans-serif;
        text-align: center;
      }

      #score-value {
        margin-top: 8px;
        font-size: 28px;
      }

      #start {
        position: absolute;
        top: 6px;
        right: -180px;
        padding: 6px 10px;
        border-radius: 6px;
        border: none;
        background: #2b7cff;
        color: #fff;
        cursor: pointer;
        z-index: 50;
      }
      #menu {
        position: absolute;
        top: 44px;
        right: -180px;
        padding: 6px 10px;
        border-radius: 6px;
        border: none;
        background: #444;
        color: #fff;
        cursor: pointer;
        z-index: 50;
      }

      #combo {
        position: absolute;
        top: -44px;
        left: 50%;
        transform: translateX(-50%);
        color: #fff;
        background: rgba(255, 255, 255, 0.06);
        padding: 6px 12px;
        border-radius: 8px;
        font-weight: bold;
        min-width: 120px;
        text-align: center;
        display: none;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
      }

      .cell {
        width: 40px;
        height: 40px;
        background: #222;
      }
      .R {
        background: crimson;
      }
      .G {
        background: seagreen;
      }
      .B {
        background: royalblue;
      }
      .Y {
        background: goldenrod;
      }

      .cursor {
        outline: 3px solid white;
        box-sizing: border-box;
      }

      .flash-white {
        background: #fff !important;
      }

      .floating {
        position: absolute;
        width: 40px;
        height: 40px;
        pointer-events: none;
        box-sizing: border-box;
      }

      #gameover {
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        justify-content: center;
        align-items: center;
        color: #fff;
        font-size: 32px;
      }

      /* modal */
      .modal-overlay {
        position: absolute;
        inset: 0;
        display: none;
        justify-content: center;
        align-items: center;
        background: rgba(0, 0, 0, 0.6);
        z-index: 200;
      }
      .modal-box {
        background: #222;
        color: #fff;
        padding: 16px;
        border-radius: 10px;
        width: 260px;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: stretch;
      }
      .modal-box h3 {
        margin: 0 0 8px 0;
      }
      .modal-btn {
        background: #333;
        color: #fff;
        border: none;
        padding: 8px 10px;
        border-radius: 6px;
        cursor: pointer;
        text-align: left;
      }
      .modal-btn.primary {
        background: #2b7cff;
      }
      .modal-close {
        position: absolute;
        top: 8px;
        right: 8px;
        background: transparent;
        border: none;
        color: #fff;
        font-size: 18px;
        cursor: pointer;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <div id="scoreboard">
        <h3>Score</h3>
        <div id="score-value">0</div>
        <div
          id="highscore"
          style="margin-top: 8px; font-size: 12px; opacity: 0.8"
        >
          High: <span id="highscore-value">0</span>
        </div>
        <div id="level" style="margin-top: 8px; font-size: 12px; opacity: 0.9">
          Level: <span id="level-value">0</span>
        </div>
      </div>

      <div id="game">
        <button id="start">Start</button>
        <button id="menu">Menu</button>
        <div id="board"></div>
        <div id="combo" style="display: none"></div>
        <!-- BGM: replace src with your audio file (e.g. assets/bgm.wav) -->
        <audio id="bgm" preload="auto" src="assets/bgm.wav"></audio>
        <div id="gameover">GAME OVER</div>
        <div id="pauseModal" class="modal-overlay">
          <div class="modal-box">
            <button class="modal-close" id="modalClose">×</button>
            <h3>Menu</h3>
            <button class="modal-btn" id="resumeBtn">Resume</button>
            <button class="modal-btn primary" id="restartBtn">Restart</button>
            <button class="modal-btn" id="settingBtn">Setting</button>
            <button class="modal-btn" id="titleBtn">Back to Title</button>
            <div id="settingsPanel" style="display: none; margin-top: 8px">
              <label style="font-size: 12px; opacity: 0.9">BGM Volume</label>
              <input
                id="bgmVol"
                type="range"
                min="0"
                max="1"
                step="0.01"
                value="0.5"
              />
              <label style="font-size: 12px; opacity: 0.9">SFX Volume</label>
              <input
                id="sfxVol"
                type="range"
                min="0"
                max="1"
                step="0.01"
                value="1"
              />
              <button class="modal-btn" id="settingsBack">Back</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      /* =====================
   설정
===================== */
      const W = 6;
      const H = 12;
      const COLORS = ["R", "G", "B", "Y"];
      const BASE_RISE_INTERVAL = 3500;
      let riseInterval = BASE_RISE_INTERVAL;
      const CELL_SIZE = 40;
      const GAP_SIZE = 2;
      const PADDING = 6;
      console.log("swipe-pong script loaded");
      // load highscore from localStorage
      try {
        const hs = localStorage.getItem("swipe-pong-highscore");
        if (hs !== null) highscore = Math.max(0, parseInt(hs, 10) || 0);
      } catch (e) {
        console.warn("localStorage not available", e);
      }

      let board = Array.from({ length: H }, () => Array(W).fill(null));
      let cursor = { x: 2, y: 8 };
      let gameOver = false;

      // 전역 상태 변수들을 스크립트 초기에 선언하여 TDZ(temporal dead zone) 문제 방지
      let animatingSwap = { active: false };
      let removing = [];
      let removalTimer = null;
      let gravityTimer = null;
      let riseTimer = null;
      let suspendGame = false;
      let gravityWasActive = false;
      let score = 0;
      let combo = 0;
      let comboTimeout = null;
      let highscore = 0;
      let level = 0;
      let gameStarted = false;

      /* 초기 줄: 바닥에서부터 몇 줄 채워서 바로 보이게 함 */
      for (let y = H - 1; y >= Math.max(0, H - 4); y--)
        board[y] = generateSafeRow(y);

      /* =====================
   렌더
===================== */
      const boardEl = document.getElementById("board");
      const gameOverEl = document.getElementById("gameover");
      const menuBtnEl = document.getElementById("menu");
      const pauseModalEl = document.getElementById("pauseModal");
      const resumeBtn = document.getElementById("resumeBtn");
      const restartBtn = document.getElementById("restartBtn");
      const settingBtn = document.getElementById("settingBtn");
      const titleBtn = document.getElementById("titleBtn");
      const modalClose = document.getElementById("modalClose");
      const settingsPanel = document.getElementById("settingsPanel");
      const settingsBack = document.getElementById("settingsBack");
      const bgmVol = document.getElementById("bgmVol");
      const sfxVol = document.getElementById("sfxVol");
      const bgmEl = document.getElementById("bgm");
      // Prefer Web Audio API for gapless looping; fall back to HTMLAudio
      const supportsWebAudio = !!(
        window.AudioContext || window.webkitAudioContext
      );
      let audioCtx = null;
      let bgmBuffer = null;
      let bgmSource = null;
      let bgmGain = null;

      async function decodeBgm(url) {
        try {
          if (!audioCtx)
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const res = await fetch(url);
          const arr = await res.arrayBuffer();
          bgmBuffer = await audioCtx.decodeAudioData(arr);
        } catch (e) {
          console.warn("decodeBgm failed", e);
          bgmBuffer = null;
        }
      }

      // modal/menu state
      let menuWasRunningRise = false;
      let htmlBgmWasPlaying = false;

      function openMenuModal() {
        if (!pauseModalEl) return;
        // suspend game systems
        menuWasRunningRise = !!riseTimer;
        if (riseTimer) {
          clearInterval(riseTimer);
          riseTimer = null;
        }
        suspendGame = true;

        // suspend audio
        try {
          if (supportsWebAudio && audioCtx && audioCtx.state === "running") {
            audioCtx.suspend().catch(() => {});
          } else if (bgmEl && !bgmEl.paused) {
            htmlBgmWasPlaying = true;
            bgmEl.pause();
          }
        } catch (e) {}

        pauseModalEl.style.display = "flex";
      }

      function closeMenuModal() {
        if (!pauseModalEl) return;
        pauseModalEl.style.display = "none";
        // resume audio
        try {
          if (supportsWebAudio && audioCtx && audioCtx.state === "suspended") {
            audioCtx.resume().catch(() => {});
          } else if (bgmEl && htmlBgmWasPlaying) {
            bgmEl.play().catch(() => {});
            htmlBgmWasPlaying = false;
          }
        } catch (e) {}

        // resume rise if it was running
        if (menuWasRunningRise) startRise();
        suspendGame = false;
      }

      function onResumeClick() {
        closeMenuModal();
      }

      function onRestartClick() {
        // close modal then restart game
        pauseModalEl.style.display = "none";
        suspendGame = false;
        resetGame();
        startGame();
      }

      function onSettingClick() {
        if (!settingsPanel) return;
        settingsPanel.style.display = "block";
      }

      function onSettingsBack() {
        if (!settingsPanel) return;
        settingsPanel.style.display = "none";
      }

      function onTitleClick() {
        // go back to title / pre-start
        pauseModalEl.style.display = "none";
        resetGame();
      }

      function onModalClose() {
        closeMenuModal();
      }

      if (menuBtnEl) menuBtnEl.addEventListener("click", openMenuModal);
      if (resumeBtn) resumeBtn.addEventListener("click", onResumeClick);
      if (restartBtn) restartBtn.addEventListener("click", onRestartClick);
      if (settingBtn) settingBtn.addEventListener("click", onSettingClick);
      if (titleBtn) titleBtn.addEventListener("click", onTitleClick);
      if (modalClose) modalClose.addEventListener("click", onModalClose);
      if (settingsBack) settingsBack.addEventListener("click", onSettingsBack);

      // keyboard: Escape opens menu when playing
      document.addEventListener("keydown", (e) => {
        // Ctrl 키로 즉시 한 줄 상승시키기
        if (e.key === "Control") {
          if (gameStarted && !gameOver && !suspendGame) {
            doRise();
          }
          return;
        }

        if (!gameStarted || gameOver || suspendGame) return;

        if (e.key === keyBindings.left) {
        }
      });

      // settings sliders
      if (bgmVol) {
        bgmVol.addEventListener("input", (e) => {
          const v = parseFloat(e.target.value);
          if (bgmEl) bgmEl.volume = v;
          if (bgmGain)
            try {
              bgmGain.gain.setValueAtTime(v, audioCtx.currentTime);
            } catch (e) {}
        });
      }
      if (sfxVol) {
        sfxVol.addEventListener("input", (e) => {
          const v = parseFloat(e.target.value);
          // adjust global SFX multiplier by changing GLOBAL_SFX_GAIN isn't possible (const), apply by overwriting variable
          // but we'll store as runtime multiplier
          window.__SFX_USER_MULT = v;
        });
      }

      function playBgmWebAudio(opts = {}) {
        if (!supportsWebAudio || !bgmBuffer) return false;
        const fadeIn = typeof opts.fadeIn === "number" ? opts.fadeIn : 0.4;
        // stop existing source if any
        try {
          if (bgmSource) bgmSource.stop();
        } catch (e) {}
        bgmSource && bgmSource.disconnect();
        bgmGain && bgmGain.disconnect();

        bgmSource = audioCtx.createBufferSource();
        bgmGain = audioCtx.createGain();
        bgmSource.buffer = bgmBuffer;
        bgmSource.loop = true;
        bgmSource.connect(bgmGain);
        bgmGain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        bgmGain.gain.setValueAtTime(0, now);
        bgmSource.start(0);
        bgmGain.gain.linearRampToValueAtTime(0.5, now + fadeIn);
        return true;
      }

      function stopBgmWebAudio(opts = {}) {
        if (!supportsWebAudio || !bgmSource || !bgmGain) return;
        const fadeOut = typeof opts.fadeOut === "number" ? opts.fadeOut : 0.25;
        const now = audioCtx.currentTime;
        try {
          bgmGain.gain.cancelScheduledValues(now);
        } catch (e) {}
        bgmGain.gain.setValueAtTime(bgmGain.gain.value || 0.5, now);
        bgmGain.gain.linearRampToValueAtTime(0, now + fadeOut);
        setTimeout(() => {
          try {
            bgmSource.stop();
          } catch (e) {}
          bgmSource.disconnect();
          bgmGain.disconnect();
          bgmSource = null;
          bgmGain = null;
        }, (fadeOut + 0.05) * 1000);
      }

      if (bgmEl) {
        bgmEl.loop = true;
        bgmEl.volume = 0.5; // 0.0 ~ 1.0
        // Fallback: some browsers may not honor `loop` reliably in all cases,
        // ensure playback restarts when ended.
        bgmEl.addEventListener("ended", () => {
          try {
            bgmEl.currentTime = 0;
            const p = bgmEl.play();
            if (p && p.catch) p.catch(() => {});
          } catch (e) {
            /* ignore */
          }
        });
      }

      // try to pre-decode BGM for gapless start (best-effort)
      if (supportsWebAudio) {
        decodeBgm("assets/bgm.wav").catch(() => {});
      }

      // -----------------
      // SFX loader / player
      // -----------------
      // global SFX normalization in dB (applied at runtime)
      const GLOBAL_SFX_DB = -6;
      const GLOBAL_SFX_GAIN = Math.pow(10, GLOBAL_SFX_DB / 20); // ~0.501
      const sfxBuffers = {};
      const sfxAudioEls = {};

      async function loadSfx(name, url) {
        if (supportsWebAudio) {
          try {
            if (!audioCtx)
              audioCtx = new (window.AudioContext ||
                window.webkitAudioContext)();
            const res = await fetch(url);
            const arr = await res.arrayBuffer();
            const buf = await audioCtx.decodeAudioData(arr);
            sfxBuffers[name] = buf;
            return buf;
          } catch (e) {
            console.warn("loadSfx webaudio failed", name, e);
            sfxBuffers[name] = null;
          }
        }
        // fallback: create HTMLAudio element
        try {
          const a = new Audio(url);
          a.preload = "auto";
          sfxAudioEls[name] = a;
          return a;
        } catch (e) {
          console.warn("loadSfx fallback failed", name, e);
          return null;
        }
      }

      function playSfx(name, opts = {}) {
        const volume = typeof opts.volume === "number" ? opts.volume : 1;
        const playbackRate =
          typeof opts.playbackRate === "number" ? opts.playbackRate : 1;
        // runtime SFX multiplier from settings (default 1)
        const userMul =
          typeof window.__SFX_USER_MULT === "number"
            ? window.__SFX_USER_MULT
            : 1;
        if (supportsWebAudio && sfxBuffers[name]) {
          try {
            if (!audioCtx)
              audioCtx = new (window.AudioContext ||
                window.webkitAudioContext)();
            const src = audioCtx.createBufferSource();
            const gain = audioCtx.createGain();
            src.buffer = sfxBuffers[name];
            src.playbackRate.value = playbackRate;
            gain.gain.value = volume * GLOBAL_SFX_GAIN * userMul;
            src.connect(gain);
            gain.connect(audioCtx.destination);
            src.start(0);
            // auto-disconnect after sound end
            src.onended = () => {
              try {
                src.disconnect();
                gain.disconnect();
              } catch (e) {}
            };
            return true;
          } catch (e) {
            // fallthrough to HTMLAudio fallback
            console.warn("playSfx webaudio error", name, e);
          }
        }
        const a = sfxAudioEls[name];
        if (a) {
          try {
            const clone = a.cloneNode();
            clone.volume = Math.max(
              0,
              Math.min(1, volume * GLOBAL_SFX_GAIN * userMul)
            );
            clone.playbackRate = playbackRate;
            clone.play().catch(() => {});
            return true;
          } catch (e) {
            console.warn("playSfx htmlaudio error", name, e);
          }
        }
        return false;
      }

      // preload expected SFX (best-effort)
      loadSfx("swap", "assets/swap.wav");
      loadSfx("remove", "assets/remove.wav");
      loadSfx("cursor", "assets/cursor.wav");

      function render() {
        try {
          boardEl.innerHTML = "";
          for (let y = 0; y < H; y++) {
            for (let x = 0; x < W; x++) {
              const d = document.createElement("div");
              d.className = "cell";

              const cellColor = board[y][x];
              const rem = removing.find((r) => r.x === x && r.y === y) || null;

              if (rem) {
                // 홀수 프레임일 때 흰색으로 보이게 함
                if (rem.frame % 2 === 1) d.classList.add("flash-white");
                else if (cellColor) d.classList.add(cellColor);
              } else {
                if (cellColor) d.classList.add(cellColor);
              }

              if (
                (x === cursor.x && y === cursor.y) ||
                (x === cursor.x + 1 && y === cursor.y)
              )
                d.classList.add("cursor");

              boardEl.appendChild(d);
            }
          }
        } catch (err) {
          console.error("render error", err);
          gameOverEl.style.display = "flex";
          gameOverEl.textContent =
            "ERROR: " + (err && err.message ? err.message : String(err));
          return;
        }
        // overlays for animations (swap floating panels)
        if (animatingSwap && animatingSwap.active) {
          const a = document.createElement("div");
          a.className = `floating ${animatingSwap.aColor || ""}`;
          const aLeft =
            (animatingSwap.curA && animatingSwap.curA.left) ||
            animatingSwap.leftA ||
            0;
          const aTop =
            (animatingSwap.curA && animatingSwap.curA.top) ||
            animatingSwap.topA ||
            0;
          a.style.left = aLeft + "px";
          a.style.top = aTop + "px";
          a.style.zIndex = 10;
          boardEl.appendChild(a);

          const b = document.createElement("div");
          b.className = `floating ${animatingSwap.bColor || ""}`;
          const bLeft =
            (animatingSwap.curB && animatingSwap.curB.left) ||
            animatingSwap.leftB ||
            0;
          const bTop =
            (animatingSwap.curB && animatingSwap.curB.top) ||
            animatingSwap.topB ||
            0;
          b.style.left = bLeft + "px";
          b.style.top = bTop + "px";
          b.style.zIndex = 11;
          boardEl.appendChild(b);
        }

        gameOverEl.style.display = gameOver ? "flex" : "none";

        // Start / Restart button visibility
        const startBtnEl = document.getElementById("start");
        if (startBtnEl) {
          if (gameOver) {
            startBtnEl.style.display = "inline-block";
            startBtnEl.textContent = "Restart";
          } else if (!gameStarted) {
            startBtnEl.style.display = "inline-block";
            startBtnEl.textContent = "Start";
          } else {
            startBtnEl.style.display = "none";
            startBtnEl.textContent = "Start";
          }
        }

        // update score UI (do not reset on game over)
        const scoreEl = document.getElementById("score-value");
        if (scoreEl) scoreEl.textContent = String(score);
        const hsEl = document.getElementById("highscore-value");
        if (hsEl) hsEl.textContent = String(highscore);

        // level display
        const levelEl = document.getElementById("level-value");
        if (levelEl) levelEl.textContent = String(level);

        // update combo overlay visibility
        const comboEl = document.getElementById("combo");
        if (comboEl) {
          if (combo > 1) {
            comboEl.style.display = "block";
            comboEl.textContent = combo + " COMBO";
          } else {
            comboEl.style.display = "none";
          }
        }
      }

      /* =====================
   입력
===================== */
      document.addEventListener("keydown", (e) => {
        // Allow cursor movement even while game systems are suspended
        if (!gameStarted || gameOver) return;

        switch (e.key) {
          case "ArrowLeft":
            cursor.x = Math.max(0, cursor.x - 1);
            playSfx("cursor", {
              volume: 0.18,
              playbackRate: 1 + (Math.random() - 0.5) * 0.08,
            });
            break;
          case "ArrowRight":
            cursor.x = Math.min(W - 2, cursor.x + 1);
            playSfx("cursor", {
              volume: 0.18,
              playbackRate: 1 + (Math.random() - 0.5) * 0.08,
            });
            break;
          case "ArrowUp":
            cursor.y = Math.max(0, cursor.y - 1);
            playSfx("cursor", {
              volume: 0.18,
              playbackRate: 1 + (Math.random() - 0.5) * 0.08,
            });
            break;
          case "ArrowDown":
            cursor.y = Math.min(H - 1, cursor.y + 1);
            playSfx("cursor", {
              volume: 0.18,
              playbackRate: 1 + (Math.random() - 0.5) * 0.08,
            });
            break;
          case " ":
            e.preventDefault();
            // don't allow swaps while game systems are suspended (e.g., during removal/gravity)
            if (suspendGame) break;
            if (swap(cursor.x, cursor.y)) {
              // player initiated action -> reset combo
              combo = 0;
            }
            break;
        }
        render();
      });

      // Global mute toggle (works anytime): press `M` to toggle mute
      document.addEventListener("keydown", (e) => {
        if (e.key && e.key.toLowerCase() === "m") {
          if (bgmEl) bgmEl.muted = !bgmEl.muted;
        }
      });

      // Reset shortcut removed per user preference

      // Start button
      const startBtn = document.getElementById("start");
      console.log("startBtn:", !!startBtn, startBtn);
      function startGame() {
        console.log("startGame called", gameStarted);
        if (gameStarted) return;
        gameStarted = true;
        // hide start button
        if (startBtn) startBtn.style.display = "none";
        gameOver = false;
        // play bgm on the user gesture (Start button)
        if (supportsWebAudio) {
          try {
            if (!audioCtx)
              audioCtx = new (window.AudioContext ||
                window.webkitAudioContext)();
            if (audioCtx.state === "suspended") audioCtx.resume();
            if (bgmBuffer) playBgmWebAudio({ fadeIn: 0.35 });
            else
              decodeBgm("assets/bgm.wav")
                .then(() => {
                  try {
                    if (audioCtx.state === "suspended") audioCtx.resume();
                  } catch (e) {}
                  playBgmWebAudio({ fadeIn: 0.35 });
                })
                .catch((e) => console.warn("bgm load failed", e));
          } catch (e) {
            console.warn("web audio play error", e);
          }
        } else if (bgmEl) {
          try {
            bgmEl.currentTime = 0;
            const p = bgmEl.play();
            if (p && p.catch)
              p.catch((e) => console.warn("bgm play blocked", e));
          } catch (e) {
            console.warn("bgm play error", e);
          }
        }
        // ensure timers reset
        if (riseTimer) clearInterval(riseTimer);
        startRise();
        render();
      }
      if (startBtn) {
        // ensure clickable
        startBtn.style.pointerEvents = "auto";
        startBtn.addEventListener("click", (e) => {
          console.log("start clicked event", e.type);
          if (gameOver) {
            resetGame();
            startGame();
          } else {
            startGame();
          }
        });
      }

      /* =====================
   상승
===================== */
      function startRise() {
        if (riseTimer) clearInterval(riseTimer);
        riseTimer = setInterval(() => {
          doRise();
        }, riseInterval);
      }

      // do NOT auto-start rise; wait for player to press Start

      // single-rise helper: perform one rise tick immediately
      function doRise() {
        console.log("manual rise");
        if (gameOver || suspendGame) return;

        if (board[0].some((v) => v !== null)) {
          gameOver = true;
          if (supportsWebAudio) stopBgmWebAudio({ fadeOut: 0.25 });
          else if (bgmEl) bgmEl.pause();
          render();
          return;
        }

        for (let y = 0; y < H - 1; y++) board[y] = board[y + 1].slice();
        board[H - 1] = generateSafeRow(H - 1);

        cursor.y = Math.max(0, cursor.y - 1);

        resolve();
        render();
      }

      /* =====================
   로직
===================== */
      function swap(x, y) {
        // animate swap instead of instant swap
        if (animatingSwap && animatingSwap.active) return false;
        if (removalTimer || gravityTimer) return false;
        animateSwap(x, y);
        return true;
      }

      // 애니메이션 상태 (초기 선언은 위에서 이미 처리됨)

      function getCellPos(x, y) {
        const colW = CELL_SIZE + GAP_SIZE;
        const left = PADDING + x * colW;
        const top = PADDING + y * colW;
        return { left, top };
      }

      function animateSwap(x, y) {
        console.log("animateSwap start", x, y);
        playSfx("swap", {
          volume: 0.35,
          playbackRate: 1 + (Math.random() - 0.5) * 0.06,
        });
        const aColor = board[y][x];
        const bColor = board[y][x + 1];

        // reserve cells (hide originals while animating)
        board[y][x] = null;
        board[y][x + 1] = null;

        // pause gravity if it's running so pieces won't fall during swap
        gravityWasActive = !!gravityTimer;
        if (gravityWasActive) {
          clearInterval(gravityTimer);
          gravityTimer = null;
        }

        const start = performance.now();
        const duration = 200; // ms (faster)
        const posA = getCellPos(x, y);
        const posB = getCellPos(x + 1, y);
        const center = {
          x: (posA.left + posB.left) / 2 + CELL_SIZE / 2,
          y: posA.top + CELL_SIZE / 2,
        };
        const dist = posB.left + CELL_SIZE / 2 - (posA.left + CELL_SIZE / 2);
        const radius = dist / 2;

        animatingSwap = {
          active: true,
          aColor,
          bColor,
          x,
          y,
          x2: x + 1,
          y2: y,
          leftA: posA.left,
          topA: posA.top,
          leftB: posB.left,
          topB: posB.top,
          center,
          radius,
          start,
          duration,
        };
        suspendGame = true;

        function frame(now) {
          const t = Math.min(
            1,
            (now - animatingSwap.start) / animatingSwap.duration
          );

          // 각도: left starts at pi, right at 0; move clockwise by pi radians
          const angleA = Math.PI - t * Math.PI;
          const angleB = 0 - t * Math.PI;

          const ax =
            animatingSwap.center.x +
            animatingSwap.radius * Math.cos(angleA) -
            CELL_SIZE / 2;
          const ay =
            animatingSwap.center.y +
            animatingSwap.radius * Math.sin(angleA) -
            CELL_SIZE / 2;
          const bx =
            animatingSwap.center.x +
            animatingSwap.radius * Math.cos(angleB) -
            CELL_SIZE / 2;
          const by =
            animatingSwap.center.y +
            animatingSwap.radius * Math.sin(angleB) -
            CELL_SIZE / 2;

          animatingSwap.curA = { left: ax, top: ay };
          animatingSwap.curB = { left: bx, top: by };
          render();

          if (t < 1) requestAnimationFrame(frame);
          else {
            // finalize swap
            board[y][x] = animatingSwap.bColor;
            board[y][x + 1] = animatingSwap.aColor;
            animatingSwap = { active: false };
            render();
            // resume game systems and resolve
            suspendGame = false;
            // if gravity was active before, resume it
            if (gravityWasActive) {
              gravityWasActive = false;
              // start gravity loop again
              setTimeout(() => gravityUntilStable(), 0);
            }
            setTimeout(() => resolve(), 0);
          }
        }

        requestAnimationFrame(frame);
      }

      function resetGame() {
        // clear timers
        if (riseTimer) {
          clearInterval(riseTimer);
          riseTimer = null;
        }
        if (gravityTimer) {
          clearInterval(gravityTimer);
          gravityTimer = null;
        }
        if (removalTimer) {
          clearInterval(removalTimer);
          removalTimer = null;
        }

        // stop animations
        animatingSwap = { active: false };
        removing = [];
        suspendGame = false;
        gravityWasActive = false;

        // reset board and state
        board = Array.from({ length: H }, () => Array(W).fill(null));
        board[11] = generateSafeRow(11);
        board[10] = generateSafeRow(10);
        cursor = { x: 2, y: 8 };
        gameOver = false;

        // reset UI
        score = 0;
        level = 0;
        const scoreEl = document.getElementById("score-value");
        if (scoreEl) scoreEl.textContent = "0";

        // stop bgm on reset
        if (supportsWebAudio) stopBgmWebAudio({ fadeOut: 0 });
        if (bgmEl) {
          try {
            bgmEl.pause();
            bgmEl.currentTime = 0;
          } catch (e) {}
        }

        // reset rise interval
        riseInterval = BASE_RISE_INTERVAL;

        render();

        // go back to pre-start state (do not auto start)
        gameStarted = false;
        if (startBtn) startBtn.style.display = "inline-block";
      }

      // timers & removal state are declared earlier to avoid TDZ
      const REMOVAL_INTERVAL = 90; // ms per frame (faster blink)
      const REMOVAL_FRAMES = 4; // 0..3, 마지막 프레임 뒤에 제거

      function resolve() {
        const matches = findMatches();
        if (!matches.length) {
          if (hasFloating()) gravityUntilStable();
          return;
        }

        startRemoval(matches);
      }

      // 한 칸씩 떨어뜨리는 중력 한 스텝
      function applyGravityStep() {
        let moved = false;
        for (let x = 0; x < W; x++) {
          for (let y = H - 2; y >= 0; y--) {
            if (board[y][x] && !board[y + 1][x]) {
              board[y + 1][x] = board[y][x];
              board[y][x] = null;
              moved = true;
            }
          }
        }
        return moved;
      }

      // 중력이 멈출 때까지 애니메이션처럼 한 칸씩 내리고, 멈추면 다시 매치 검사
      function gravityUntilStable() {
        if (gravityTimer) return;
        console.log("gravity start");
        // suspend rise while gravity is resolving to avoid race with rising
        suspendGame = true;
        gravityTimer = setInterval(() => {
          const moved = applyGravityStep();
          if (moved) {
            render();
          } else {
            clearInterval(gravityTimer);
            gravityTimer = null;
            // gravity finished -> resume game systems and check for new matches
            suspendGame = false;
            setTimeout(() => resolve(), 0);
          }
        }, 80);
      }

      function updateLevelAndRise() {
        const newLevel = Math.floor(score / 1000);
        if (newLevel !== level) {
          level = newLevel;
          // simple linear speed up: decrease interval by 300ms per level, min 600ms
          riseInterval = Math.max(600, BASE_RISE_INTERVAL - level * 300);
          // restart rise timer with new interval
          if (riseTimer) {
            startRise();
          }
        }
      }

      function hasFloating() {
        for (let x = 0; x < W; x++) {
          for (let y = 0; y < H - 1; y++) {
            if (board[y][x] && !board[y + 1][x]) return true;
          }
        }
        return false;
      }

      // 중복 좌표 제거 후 제거 리스트에 추가하고 애니메이션 시작
      function startRemoval(coords) {
        const key = (x, y) => `${x},${y}`;
        const seen = new Set();
        coords.forEach(([x, y]) => seen.add(key(x, y)));

        const removedCount = seen.size;

        // combo: increment for each removal wave
        combo++;

        // calculate score: per piece base 10, plus 10*combo per piece
        const perPiece = 10 + 10 * combo;
        const points = removedCount * perPiece;
        score += points;

        // update highscore if needed and persist
        if (score > highscore) {
          highscore = score;
          try {
            localStorage.setItem("swipe-pong-highscore", String(highscore));
          } catch (e) {
            /* ignore storage errors */
          }
        }

        // update level based on score thresholds (every 1000 points)
        updateLevelAndRise();

        // show combo overlay briefly
        const comboEl = document.getElementById("combo");
        if (comboEl && combo > 1) {
          comboEl.style.display = "block";
          comboEl.textContent = combo + " COMBO";
          if (comboTimeout) clearTimeout(comboTimeout);
          comboTimeout = setTimeout(() => {
            if (comboEl) comboEl.style.display = "none";
            comboTimeout = null;
          }, 1200);
        }

        // push unique coords with frame counter
        // suspend rise/other systems while removal animation runs to avoid
        // index mismatch when rows might shift (rise) during removal
        suspendGame = true;
        // play removal sfx once per removal wave (reduced volume)
        playSfx("remove", { volume: 0.35, playbackRate: 1 });
        for (const s of seen) {
          const [x, y] = s.split(",").map(Number);
          removing.push({ x, y, frame: 0 });
        }

        if (removalTimer) return;
        removalTimer = setInterval(() => {
          // advance frames
          for (let i = removing.length - 1; i >= 0; i--) {
            removing[i].frame++;
            if (removing[i].frame >= REMOVAL_FRAMES) {
              const { x, y } = removing[i];
              board[y][x] = null;
              removing.splice(i, 1);
            }
          }
          render();

          if (removing.length === 0) {
            clearInterval(removalTimer);
            removalTimer = null;
            // 제거 완료 후 중력 적용
            if (hasFloating()) {
              // keep suspendGame true while gravity resolves
              gravityUntilStable();
            } else {
              // no gravity to wait for -> resume game systems
              suspendGame = false;
              setTimeout(() => resolve(), 0);
            }
          }
        }, REMOVAL_INTERVAL);
      }

      function findMatches() {
        const out = [];

        // 가로
        for (let y = 0; y < H; y++) {
          let c = 1;
          for (let x = 1; x <= W; x++) {
            const cur = board[y][x];
            const prev = board[y][x - 1];
            if (cur && cur === prev) c++;
            else {
              if (c >= 3 && prev)
                for (let i = 0; i < c; i++) out.push([x - 1 - i, y]);
              c = 1;
            }
          }
        }

        // 세로
        for (let x = 0; x < W; x++) {
          let c = 1;
          for (let y = 1; y <= H; y++) {
            const cur = board[y]?.[x];
            const prev = board[y - 1][x];
            if (cur && cur === prev) c++;
            else {
              if (c >= 3 && prev)
                for (let i = 0; i < c; i++) out.push([x, y - 1 - i]);
              c = 1;
            }
          }
        }
        return out;
      }

      /* =====================
   안전한 줄 생성
===================== */
      function generateSafeRow(y) {
        const row = [];

        for (let x = 0; x < W; x++) {
          let choices = COLORS.slice();

          // 가로 3 방지
          if (x >= 2 && row[x - 1] === row[x - 2]) {
            choices = choices.filter((c) => c !== row[x - 1]);
          }

          // 세로 3 방지
          if (
            y >= 2 &&
            board[y - 1][x] &&
            board[y - 1][x] === board[y - 2][x]
          ) {
            choices = choices.filter((c) => c !== board[y - 1][x]);
          }

          row[x] = choices[Math.floor(Math.random() * choices.length)];
        }
        return row;
      }

      /* =====================
   시작
===================== */
      render();
    </script>
  </body>
</html>
